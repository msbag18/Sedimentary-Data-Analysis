---
title: "Sedimentary Data Analysis"
subtitle: "Part 1 - Initialising Raw Data through Summary Statistics"
output: 
  html_document: 
    number_sections: true
---
# Section 1: Importing libraries and raw data
```{r}
#Libraries
library(geostats)
library(MASS)

#Source files
erodibility <- read.csv(file = "erodibility.csv" , header = TRUE)
locations <- read.csv(file = "locations.csv", header = TRUE, row.names = 1)
```

# Section 2: Visualising the data 
## Subsection 1: Probability distribution of erodibility for first four samples
```{r}
i <- 1
n = 4 #Number of sample that are to be visualized starting with sample 1
x = n + 1 

par(mfrow = c(2,2),mar=c(4,4,2,1))
while (i < x) { 
  m <- mean(erodibility[,i])#mean
  s <- sdsamp1<- sd(erodibility[,i])
  probsamp <- dnorm(0:200,m,s) #As data is continuous, probability distribution of erodibility is found using normal distribution
  plot(probsamp, main = c("Sample",i), xlab = "Erodibility (mm/[yr.ha])",ylab = "Probability", type = "l")
  rug(erodibility[,i])
  i = i +1
}
```

## Subsection 2: Boxplot
```{r}
par(mfrow = c(1,1),mar=c(4,4,1,1))
sampname <- c(1:ncol(erodibility))
names(erodibility)<- sampname
boxplot(erodibility,xlab="Sample", ylab ="Erodibility (mm/[yr.ha])", horizontal = FALSE) #Individual boxplots for each sample as they are at different locations
```

# Section 3: Mean and standard error of erodibility 
```{r}
z = ncol(erodibility)
y = z + 1
Mean <- matrix(data = NA, nrow = ncol(erodibility), ncol = 1)
SE <- matrix(data = NA, nrow = ncol(erodibility), ncol = 1) #Standard error in this case would be equal to standard deviation

j <- 1
while (j < y) {
  Mean[j] = exp(mean(log(erodibility[,j]))) #Used log transformation due to the skewing of the raw data observed
  SE[j] <- sd(log(erodibility[,j]))/sqrt(length(erodibility[,j]))
  j = j +1
}
```

# Section 4: Estimating erosion rate
```{r}
S <- locations[,4] #Topographic parameter
t <- locations[,5] #Tree cover parameter
cER <- matrix(data = NA, nrow = ncol(erodibility), ncol = 1) #calculated erosion rate
k <- 1 
while (k < y) {
  cER[k] <- (Mean[k]*S[k])/t[k]
  k = k +1
}
```

# Section 5: Propagating the uncertainty
```{r}
UE =  SE/Mean #Uncertainty in erodibility
US <-  0.1 #Uncertainty in slope as given 
UT <- 1/t[1:ncol(erodibility)] #As tree cover follows a poisson distribution (distribution of discrete rare events independent of others)

sER = sqrt((UE)^2 + (US)^2 + (UT)^2) * cER
```

# Section 6: Scatter Plot 
```{r}
par(mfrow = c(1,1),mar=c(4,4,1,1))
plot(cER,sER, xlab = "Calculated erosion rate (mm/yr)", ylab = "Uncertainty in calculated erosion rate (mm/yr)", main = "Scatter plot of uncertainty of erosion rate against erosion rate")
```

# Section 7: Colour Plot 
## Subsection 1: Erosion Rate as a function of location
```{r}
NS <- locations[,3]
EW <- locations[,2]
colourplot(X = EW, Y = NS, Z = cER, xlab= "Eastings", ylab= "Northings", main = "Erosion rate as a function location", key.title=title('[mm/yr]'))
```


---
subtitle: "Part 2 - Comparing the distribution of sediments"
---
# Section 1: Comparing statistical difference from distributions using Kolmogorov-Smirnov test
```{r}
#Choosing location of two data 
L1 <- 1
L2 <- 10

#Visualizing the two distribution 
qqplot(x=erodibility[,L1], y=erodibility[,L2], xlab = c("Sample", L1), ylab =c("Sample",L2))
abline(0,1)

#Quantitatively comparing the two samples 
test1 <- ks.test(x=erodibility[,L1], y=erodibility[,L2])
```

# Section 2: Comparing distribution to normal distribution 
```{r}
#Normalising erodibility (K) values in the first sample
#For k values in first sample
S <- 1 #sample number chosen
K <- (erodibility[,S] - Mean[S])/sd(erodibility[,S])

#Visualising normalised data
qqnorm(K)
abline(0,1)

#Comparing normalised data with a normal distribution 
test2 <- ks.test(K, "pnorm")
```

# Section 3: Comparing distribution with a logarithmic normal distribution 
```{r}
#Log conversion
logerodibility <- log(erodibility[,S])

#Normalising 
mlog <- mean(logerodibility)
slog <- sd(logerodibility)
logK <- (logerodibility - mlog)/slog

#Visualizing normalised data
qqnorm(logK)
abline(0,1)

#testing 
test3 <- ks.test(logK, "pnorm")
```

# Section 4: Comparing estimated and measured rates
```{r}
#Measured erosion rates
mER <- locations$erosion[1:ncol(erodibility)]

#Plotting
plot(mER, cER, xlab = "Measured erosion rate (mm/yr)", ylab = "Calculated erosion rate (mm/yr)", main = "Comparing calculated and measured erosion rates at different locations" )
```

## Subsection 1: Correlation coefficient and t-test
```{r}
#correlation coefficient, cc
r <- cor(mER, cER)

#testing its statistical significance
n <-  nrow(locations)
t <- (r*sqrt(n-2))/(sqrt(1-(r^2)))

#quantile distribution of t 
q <- pt(q=t,df=n-1, lower.tail = FALSE) #df taken as n-1 because one reference data which was measured independently and one statistical data which involved estimation
```

## Subsection 2: Regression line through calcuated and measured erosion rates
```{r}
fit <- lm(cER~mER)

#Plotting
plot(mER, cER, xlab = "Measured erosion rate (mm/yr)", ylab = "Calculated erosion rate (mm/yr)", main = "Comparing calculated and measured erosion rates at different locations" )
abline(fit) #line

xce <- seq(from=min(mER), to=max(mER),length.out = 89)#confidence envelope
yce <- predict(fit, newdata=data.frame(mER=xce), interval = "confidence", level = 0.95)
matlines(xce,yce, lty=2, col = "black")
yced <- predict(fit, newdata=data.frame(mER=xce), interval = "prediction", level = 0.95)
matlines(xce,yced, lty=3, col = "black")
```

## Subsection 3: Logarithmic transformation for correlation, t-test and regression
```{r}
#Log conversion
logE <- log(cER) #estimated 
logmER <- log(mER) #measured

#Plotting
plot(logmER, logE, xlab = "Log of measured erosion rate", ylab = "Log of estimated erosion rate", main = "Comparing log of estimated and measured erosion rates")

#correlation coefficient, cc
logr <- cor(logmER, logE)

#testing its statistical significance
logt <- (logr*sqrt(n-2))/(sqrt(1-(logr^2)))

#quantile distribution of t 
qlogt <- pt(logt, df=(n-1), lower.tail = FALSE) #df taken as n-1 because one reference and one statistical data

fitlog <- lm(logE~logmER)
abline(fitlog) #line

logxce <- seq(from=min(logmER), to=max(logmER),length.out = 89)#confidence enveloppe
logyce <- predict(fitlog, newdata=data.frame(logmER=logxce), interval = "confidence", level = 0.95)
matlines(logxce,logyce, lty=2, col = "black")
logyced <- predict(fitlog, newdata=data.frame(logmER=logxce), interval = "prediction", level = 0.95)
matlines(logxce,logyced, lty=3, col = "black")
```

---
Part 3: Qualitative visualisation of sedimentary data
---
# Section 1: Visualising sedimentary data 
## Subsection 1: In a ternary diagram 
```{r}
#Creating a matrix with three chosen sediments types 
ternary_mat <- locations[,c('clay','silt','sand')]

#Generating the ternary diagram
ternary(ternary_mat, labels=c("Clay", "Silt", "Sand"),type='p', col='grey')
```

## Subsection 2: Through a biplot
```{r}
#Principle Component Analysis
components <- clr(ternary_mat) #making the data easier to read
pc <- prcomp(components) #principal component analysis of the data

#Generating biplot
biplot(pc, col=c("grey", "black"), xlim=c(-0.2,0.25)) #change limits slightly to allow clay to be viewed on the biplot
```

# Section 2: Interpolating Erosion Rates
```{r}
#Parameters for semivariogram 
X <- locations$E #east west axis
Y <- locations$N #north south axis
Z <- locations$erosion #value for erosion

#Finding the right semivariogram
svm_exp <- semivariogram(x=X,y=Y,z=Z,model='exponential', main='Exponential Semivariogram') #Fitting exponential model
svm_gau <- semivariogram(x=X,y=Y,z=Z,model='gaussian', main='Gaussian Semivariogram') #Fitting Gaussian model
svm_sph <- semivariogram(x=X,y=Y,z=Z,model='spherical', main='Spherical Semivariogram') #Fitting spherical model

#Gaussian distribution seems to subjectively fit the line, therefore, svm_gau is used for interpolation
xi <- seq(from=min(X),to=max(X),length.out=50)
yi <- seq(from=min(Y),to=max(Y),length.out=50)
zi <- kriging(x=X,y=Y,z=Z,svm=svm_gau,xi=xi,yi=yi,grid=TRUE)
colourplot(x=xi,y=yi,z=zi,key.title=title('Erosion rates (mm/yr)'), xlab='Eastings', ylab='Northings', main ='Interpolation of erosion rates' )

#Uncertainties with interpolation 
zi_error <- kriging(x=X,y=Y,z=Z,svm=svm_gau,xi=xi,yi=yi,grid=TRUE,err=TRUE)
colourplot(x=xi,y=yi,z=sqrt(zi_error),key.title=title('s[Erosion rate]/Erosion Rate'), xlab='Eastings', ylab='Northings', main = 'Interpolation Uncertainty')
```

# Section 3: Evaluating the model 
## Subsection 1: Dividing samples into two groups
```{r}
biplot(pc, col=c("grey", "black"), xlim=c(-0.2,0.25))
```
Bi-plot shows anti-correlation between clay and sand and silt which makes it more logically to separate them into two groups based on the latter, that is using PC1 component of pc (which has already undergone principal component analysis). I decided to separate the two groups at PC1 = 0 (which is where I visually see the separation)

```{r}
#defining group
cutoff <- 0 # this could be shifted to the left or right depending on the biplot

silty <- which(pc$x[,1]<=cutoff) # left hand side of the biplot
silty <- cbind(silty, locations[silty,])
clayey <- which(pc$x[,1]>cutoff) # right hand side of the biplot
clayey <- cbind(clayey, locations[clayey,])
```

# Section 4:Illustrating the two groups on the interpolated model 
```{r}
#Gaussian distribution seems to subjectively fit the line, therefore, svm_gau is used for interpolation
xi <- seq(from=min(X),to=max(X),length.out=50)
yi <- seq(from=min(Y),to=max(Y),length.out=50)
zi <- kriging(x=X,y=Y,z=Z,svm=svm_gau,xi=xi,yi=yi,grid=TRUE)
colourplot(x=xi,y=yi,z=zi,key.title=title('Measured erosion rates (mm/yr)'), xlab='Eastings', ylab='Northings', extra={points(x=clayey$E,y=clayey$N,pch=21,bg='grey'); extra=points(x=silty$E,y=silty$N, pch=21,bg='white')})
```
